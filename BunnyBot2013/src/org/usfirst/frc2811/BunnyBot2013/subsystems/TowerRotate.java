// RobotBuilder Version: 0.0.2
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.


package org.usfirst.frc2811.BunnyBot2013.subsystems;

import org.usfirst.frc2811.BunnyBot2013.RobotMap;
import org.usfirst.frc2811.BunnyBot2013.commands.*;
import edu.wpi.first.wpilibj.*;
import edu.wpi.first.wpilibj.CounterBase.EncodingType; import edu.wpi.first.wpilibj.Encoder.PIDSourceParameter;

import edu.wpi.first.wpilibj.command.Subsystem;


/**
 *
 */
public class TowerRotate extends Subsystem {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    Encoder towerRotateSensor = RobotMap.towerRotateTowerRotateSensor;
    SpeedController towerRotateMotor = RobotMap.towerRotateTowerRotateMotor;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private double MOTOR_SPEED = 0.5;
    
    //This is our physical zero. When the encoder is at this value,
    //our robot will be tripping the end-stop switch
    private int encoderAtEndStop ;
    
    //This is the offset. The encoder counts this many ticks betwen 90 degree rotations
    private int encoder90DegreeOffset;     
    private int encoderNeg90Degrees;
    private int encoder0Degrees;
    private int encoder90Degrees;
    private double currentAngle;
    private int currentPosition;
    
    //This is the angle we want to go to
    public double targetAngle;
    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	
        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
    }
    
    public void execute(){
        //get the current number of ticks from the encoder
        currentPosition=RobotMap.towerRotateTowerRotateSensor.get();
        
        //convert to degrees
        currentAngle=encoderTicksToDegrees(currentPosition);      
        
        if(currentAngle>90){
            towerRotateMotor.set(0);
        }
        
        else if(currentAngle<-90){
            towerRotateMotor.set(0);
        }

        else{
                //Ok, so now we're in the normal range
                //Let's see where we want to be, and where we should be
                if(targetAngle<currentAngle){
                    turnLeft();
                }//go counterclockwise
                else if (targetAngle>currentAngle){
                    turnRight();
                }//go clockwise
                else{
                    towerRotateMotor.set(0);
                }//we're doing great! On target!
                
        }
    //end of execute function    
    }
    
    public void setHomePositions(){
        //Save the physical encoder positions so we can easily check our limits
        encoderNeg90Degrees=encoderAtEndStop;
        encoder0Degrees=encoderNeg90Degrees+encoder90DegreeOffset;
        encoder90Degrees=encoder0Degrees+encoder90DegreeOffset;
        
        //set the turret to center
        targetAngle=0;

    }
    private double encoderTicksToDegrees(int ticks){
        double degrees;
        //divide the current amount of ticks by the range to get our
        //relative rotation to our maximum possible
        //and then multiply by 90 to convert it to degrees
        degrees=((double)ticks*90.0/encoder90DegreeOffset);
        return degrees;
    }
    
    public void turnAmount(double amt){
        towerRotateMotor.set(amt);
    }    
    public void turnRight(){
        towerRotateMotor.set(MOTOR_SPEED);
    }
    public void turnLeft(){
        towerRotateMotor.set(-MOTOR_SPEED);
    }
    public void stop(){
        towerRotateMotor.set(0.0);
    }
}

